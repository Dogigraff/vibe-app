/**
 * E2E Encryption: Room Key Management
 *
 * Room key = AES-GCM 256-bit symmetric key, unique per party.
 * Generated by the first party member, then sealed (wrapped) for each
 * other member using ECDH key agreement + AES-KW.
 *
 * Flow:
 * 1. Creator generates room key via generateRoomKey()
 * 2. For each member, seal room key with their ECDH public key
 * 3. Store encrypted room key per user in party_room_keys table
 * 4. Recipient unseals with their private key
 */

import { importPublicKey, importPrivateKey, arrayBufferToBase64, base64ToArrayBuffer } from "./keys";

const AES_GCM_PARAMS: AesKeyGenParams = { name: "AES-GCM", length: 256 };

/** Generate a new AES-GCM 256-bit room key. */
export async function generateRoomKey(): Promise<CryptoKey> {
    return crypto.subtle.generateKey(AES_GCM_PARAMS, true, ["encrypt", "decrypt"]);
}

/** Export room key to base64. */
export async function exportRoomKey(key: CryptoKey): Promise<string> {
    const raw = await crypto.subtle.exportKey("raw", key);
    return arrayBufferToBase64(raw);
}

/** Import room key from base64. */
export async function importRoomKey(base64: string): Promise<CryptoKey> {
    const raw = base64ToArrayBuffer(base64);
    return crypto.subtle.importKey("raw", raw, AES_GCM_PARAMS, true, [
        "encrypt",
        "decrypt",
    ]);
}

/**
 * Seal (wrap) room key for a recipient using ECDH.
 * - Derives a shared AES-KW wrapping key from sender's private + recipient's public
 * - Wraps the room key with AES-KW
 * @returns base64 of the wrapped room key
 */
export async function sealRoomKey(
    roomKey: CryptoKey,
    senderPrivateKeyPkcs8: string,
    recipientPublicKeySpki: string
): Promise<string> {
    const senderPrivate = await importPrivateKey(senderPrivateKeyPkcs8);
    const recipientPublic = await importPublicKey(recipientPublicKeySpki);

    // ECDH → shared secret → AES-KW wrapping key
    const wrapKey = await crypto.subtle.deriveKey(
        { name: "ECDH", public: recipientPublic },
        senderPrivate,
        { name: "AES-KW", length: 256 },
        false,
        ["wrapKey"]
    );

    const wrapped = await crypto.subtle.wrapKey("raw", roomKey, wrapKey, "AES-KW");
    return arrayBufferToBase64(wrapped);
}

/**
 * Unseal (unwrap) room key received from a sender.
 * - Derives the same shared AES-KW key from recipient's private + sender's public
 * - Unwraps the room key
 * @returns CryptoKey for AES-GCM encrypt/decrypt
 */
export async function unsealRoomKey(
    wrappedRoomKeyBase64: string,
    recipientPrivateKeyPkcs8: string,
    senderPublicKeySpki: string
): Promise<CryptoKey> {
    const recipientPrivate = await importPrivateKey(recipientPrivateKeyPkcs8);
    const senderPublic = await importPublicKey(senderPublicKeySpki);

    const unwrapKey = await crypto.subtle.deriveKey(
        { name: "ECDH", public: senderPublic },
        recipientPrivate,
        { name: "AES-KW", length: 256 },
        false,
        ["unwrapKey"]
    );

    const wrapped = base64ToArrayBuffer(wrappedRoomKeyBase64);
    return crypto.subtle.unwrapKey(
        "raw",
        wrapped,
        unwrapKey,
        "AES-KW",
        AES_GCM_PARAMS,
        true,
        ["encrypt", "decrypt"]
    );
}
